(* ::Package:: *)

(* ::Chapter:: *)
(*Exact diagonalization: Bose\[Dash]Hubbard model*)


Remove["Global`*"]


(* ::Section:: *)
(*Functions*)


flattenFirst = (Flatten[#, 1] &);


(* `siteNum`: M in the paper
 * `particleNum`: N in the paper
 *)
getBasis[siteNum_Integer, particleNum_Integer] :=
  N @ ReverseSort @ flattenFirst[
    Permutations[PadRight[#, siteNum]] & /@ IntegerPartitions[particleNum, siteNum]]


adjacentIndices[siteNum_Integer] := DeleteDuplicates @ flattenFirst[
  Permutations /@ Append[Table[{i, i + 1}, {i, siteNum - 1}], {siteNum, 1}]]


(* `basis`: a list of vectors, generated by `getBasis[]`
 * `indices`: generated by `adjacentIndices[]`
 * `couplingConst`: U/J
 *)
getMatrix[basis_List, indices_List, couplingConst_] := Module[{
    basisNumRange, vectorPositions, kineticPart, interactionPart},
  basisNumRange = Range @ Length @ basis;
  vectorPositions = AssociationThread[basis -> basisNumRange];
  kineticPart = flattenFirst[Normal /@ MapIndexed[
    Function[{v, i}, KeyMap[{First @ i, #} &, v]],
    KeyMap[vectorPositions] /@ Association /@ Outer[operatorADaggerA, basis, indices, 1]]];
  interactionPart = MapThread[{#1, #1} -> #2 &,
    {basisNumRange, couplingConst * operatorHInteraction /@ basis}];
  SparseArray @ Join[kineticPart, interactionPart]]
operatorADaggerA[vector_List, {i_Integer, j_Integer}, return_: Nothing] := Module[
    {vi = vector[[i]], vj = vector[[j]]},
  If[Positive @ vj,
    (MapAt[# + 1 &, i] @ MapAt[# - 1 &, j] @ vector) -> -Sqrt[(vi + 1) * vj],
    return]]
operatorHInteraction[vector_List] := 0.5 * Sum[i^2 - i, {i, vector}]


(* The original MATLAB code uses `eigs(H,2,'sa')`, where `'sa'` means `'smallestreal'`. *)
getEigensystem[matrix_, num_Integer: 1] :=
  -Eigensystem[N[-matrix], num, Method -> {"Arnoldi", "Criteria" -> "RealPart"}]
getGroundEigensystem[matrix_] :=
  First /@ getEigensystem[matrix, 1]


(* SPDM = single-particle density matrix *)
getSPDM[groundState_List, basis_List, {i_Integer, j_Integer}] := Module[{
    $mapFunc, $mergeFunc},
  $mapFunc[vector_ -> coeff_, e_] := vector -> coeff * e;
  $mapFunc[Null, _] := Nothing;
  $mergeFunc[{a_, b_}] := a * b;
  $mergeFunc[{a_}] := 0;
  Total @ Merge[$mergeFunc] @ {
    AssociationThread[basis -> groundState],
    Association @ MapThread[$mapFunc] @
      {operatorADaggerA[#, {i, j}, Null] & /@ basis, groundState}}]


getCondensateFraction[groundState_List, basis_List, siteNum_Integer, particleNum_Integer] :=
  First[Eigenvalues[#, 1]] / particleNum & @
    Table[getSPDM[groundState, basis, {i, j}], {i, siteNum}, {j, siteNum}]


(* ::Section:: *)
(*Test*)


(* The length sequence of `getBasis[n, n]` is https://oeis.org/A001700. *)
Echo @ AbsoluteTiming[Length[getBasis[#, #]] & /@ Range[10]];


n = 7;
k = 20.0;
Echo @ First @ AbsoluteTiming[basis = getBasis[n, n]];
Echo @ First @ AbsoluteTiming[indices = adjacentIndices[n]];
Echo @ First @ AbsoluteTiming[matrix = getMatrix[basis, indices, k]];
Echo @ First @ AbsoluteTiming[eigen = getGroundEigensystem[matrix]];
Echo @ First @ AbsoluteTiming[spdm = getSPDM[Last @ eigen, basis, {1, Ceiling[n / 2]}]];
Echo @ First @ AbsoluteTiming[fc = getCondensateFraction[Last @ eigen, basis, n, n]];
Echo[Length @ basis, "basis len: "];
Echo[indices, "indices: "];
Echo[MatrixPlot[matrix, PlotLegends -> Automatic, ImageSize -> Medium], "matrix: "];
Echo[eigen // Short, "eigen-system: "];
Echo[spdm, "SPDM: "];
Echo[fc, "condensate fraction: "];


nRange = Range[3, 5];
kRange = Range[0, 20, 0.5];
test[n_] := Module[
  {basis, indices, matrix, eigen},
  basis = getBasis[n, n];
  indices = adjacentIndices[n];
  matrix = ParallelMap[getMatrix[basis, indices, #] &, kRange];
  eigen = getGroundEigensystem /@ matrix;
  <|
    "spdm" -> ParallelMap[getSPDM[Last @ #, basis, {1, Ceiling[n / 2]}] &, eigen],
    "fc" -> ParallelMap[getCondensateFraction[Last @ #, basis, n, n] &, eigen]
  |>
]

result = {};
Echo[AbsoluteTiming[AppendTo[result, test @ #];]] & /@ nRange;

ListLinePlot[Transpose[{kRange, #}] & /@ -Merge[result, # &]["spdm"],
  PlotRange -> All, Mesh -> All, PlotLegends -> nRange]
ListLinePlot[Transpose[{kRange, #}] & /@ -Merge[result, # &]["fc"],
  PlotRange -> All, Mesh -> All, PlotLegends -> nRange]
