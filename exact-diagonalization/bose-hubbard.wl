(* ::Package:: *)

(* ::Chapter:: *)
(*Exact diagonalization: Bose\[Dash]Hubbard model*)


Remove["Global`*"]


(* ::Section:: *)
(*Functions*)


flattenFirst = (Flatten[#, 1] &);


(* `siteNum`: M in the paper
 * `particleNum`: N in the paper
 *)
getBasis[siteNum_, particleNum_] :=
  ReverseSort @ flattenFirst[
    Permutations[PadRight[#, siteNum]] & /@ IntegerPartitions[particleNum, siteNum]]


(* `basis`: a list of vectors, generated by `getBasis[]`
 * `couplingConst`: U / J
 *)
getMatrix[basis_, couplingConst_] := With[{basisNumRange = Range @ Length @ basis},
  SparseArray @ Join[
    kineticPart[basis, AssociationThread[basis -> basisNumRange], basisNumRange],
    interactionPart[basis, couplingConst, basisNumRange]]]

kineticPart[basis_, positionMap_, basisNumRange_] :=
  flattenFirst @ MapThread[kineticPartMapFunc] @ {
    Apply[{positionMap[#1], #2} &, DeleteCases[{_, 0.}] /@
      Transpose[{operatorADaggerAState[basis], operatorADaggerAValue[basis]}, {3, 1, 2}], {2}],
    basisNumRange}
operatorADaggerAState[basis_] := With[{len = Length @ First @ basis},
  Outer[Plus, basis, #, 1] & @
    flattenFirst[NestList[RotateRight, PadRight[#, len], len - 1] & /@ {{1, -1}, {-1, 1}}]]
operatorADaggerAValue[basis_] :=
  -Sqrt[(#1 + 1.) * #2] & @@@ (Join[#, Reverse[#, {2}]] & @ Partition[#, 2, 1, 1]) & /@ basis
kineticPartMapFunc[stateValuePairs_, index_] :=
  ({index, #1} -> #2) & @@@ stateValuePairs

interactionPart[basis_, couplingConst_, basisNumRange_] :=
  MapThread[{#1, #1} -> #2 &,
    {basisNumRange, 0.5 * couplingConst * Sum[i * (i - 1), {i, #}] & /@ basis}]


(* The original MATLAB code uses `eigs(H,2,'sa')`, where `'sa'` means `'smallestreal'`. *)
getEigensystem[matrix_, num_: 1] :=
  -Eigensystem[N[-matrix], num, Method -> {"Arnoldi", "Criteria" -> "RealPart"}]
getGroundEigensystem[matrix_] :=
  First /@ getEigensystem[matrix, 1]


getSPDM[groundState_, basis_, {i_, j_}] :=
  Total @ Merge[AssociationThread /@ {
    basis -> groundState,
    (basis + ConstantArray[ReplacePart[
        ConstantArray[0, Length @ First @ basis], {i -> 1, j -> -1}], Length @ basis])
      -> (Sqrt[(#[[i]] + 1.) * #[[j]]] & /@ basis) * groundState
  }, getSPDMMergeFunc]
getSPDMMergeFunc[{a_, b_}] := a * b
getSPDMMergeFunc[{a_}] := 0.

(* I don't know why but it just equals to 1. *)
getSPDM[groundState_, basis_, {i_, i_}] := 1.
  (*(groundState * groundState) . basis[[All, i]]*)


getCondensateFraction[groundState_, basis_, siteNum_, particleNum_] := With[{
    eval = Table[getSPDM[groundState, basis, {1, i}], {i, 2, Ceiling[(siteNum + 1) / 2]}]},
  First[Eigenvalues[#, 1]] / particleNum & @
    NestList[RotateRight, Join[{1.}, eval, Reverse[eval][[2 - Mod[siteNum, 2] ;;]]], siteNum - 1]]


(* ::Section:: *)
(*Test*)


(* The length sequence of `getBasis[n, n]` is https://oeis.org/A001700. *)
Echo @ AbsoluteTiming[Length[getBasis[#, #]] & /@ Range[10]];


n = 9;
k = 1.;
Echo @ First @ AbsoluteTiming[basis = getBasis[n, n]];
Echo @ First @ AbsoluteTiming[matrix = getMatrix[basis, k]];
Echo @ First @ AbsoluteTiming[eigen = getGroundEigensystem[matrix]];
Echo @ First @ AbsoluteTiming[spdm = getSPDM[Last @ eigen, basis, {1, Floor[n / 2]}]];
Echo @ First @ AbsoluteTiming[fc = getCondensateFraction[Last @ eigen, basis, n, n]];
Echo[Length @ basis, "basis len: "];
Echo[MatrixPlot[matrix, PlotLegends -> Automatic, ImageSize -> Medium], "matrix: "];
Echo[eigen // Short, "eigen-system: "];
Echo[spdm, "SPDM: "];
Echo[fc, "condensate fraction: "];


nRange = Range[3, 7];
kRange = Subdivide[20., 32];
test[n_] := Module[{basis, matrix, eigen},
  basis = getBasis[n, n];
  matrix = ParallelMap[getMatrix[basis, #] &, kRange];
  eigen = getGroundEigensystem /@ matrix;
  <|
    "spdm" -> ParallelMap[getSPDM[Last @ #, basis, {1, Floor[n / 2]}] &, eigen],
    "fc" -> ParallelMap[getCondensateFraction[Last @ #, basis, n, n] &, eigen]
  |>]

result = {};
Echo[AbsoluteTiming[AppendTo[result, test @ #];], "N = " <> ToString @ # <> ": "] & /@ nRange;

ListLinePlot[Transpose[{kRange, #}] & /@ Merge[result, # &]["spdm"],
    PlotRange -> All, Mesh -> All, PlotLegends -> nRange]
ListLinePlot[Transpose[{kRange, #}] & /@ Merge[result, # &]["fc"],
    PlotRange -> All, Mesh -> All, PlotLegends -> nRange]
